# 微前端

## 一、引言

随着技术的发展，前端应用承载的内容也日益复杂，基于此而产生的各种问题也应运而生，从`MPA`（`Multi-Page Application`，多页应用）到SPA（`Single-Page Application`，单页应用），虽然解决了切换体验的延迟问题，但也带来了首次加载时间长，以及工程爆炸增长后带来的巨石应用（`Monolithic`）问题；对于`MPA`来说，其部署简单，各应用之间天然硬隔离，并且具备技术栈无关、独立开发、独立部署等特点。要是能够将这两方的特点结合起来，会不会给用户和开发带来更好的用户体验？至此，在借鉴了微服务理念下，微前端便应运而生。

## 二、微前端介绍

### 1. 微服务概念

2014年，Martin Fowler 和 James Lewis 共同提出了 微服务 的概念。微服务是一种开发软件的架构和组织方法，其中软件由通过明确定义的 API 进行通信的 小型独立服务 组成。

微服务的主要思路是：

* 将应用 分解 为小的、互相连接的微服务，一个微服务完成某个 特定功能 。
* 每个微服务都有自己的业务逻辑和适配器，不同的微服务，可以使用 不同的技术 去实现。
* 使用 统一的网关 进行调用。

![微服务](https://d1.awsstatic.com/Developer%20Marketing/containers/monolith\_1-monolith-microservices.70b547e30e30b013051d58a93a6e35e77408a2a8.png)

可以看到微服务的主要思路是化繁为简，通过更加细致的划分，使得服务内部更加内聚，服务之间耦合性降低，有利于项目的团队开发和后期维护。把微服务的概念应用到前端， 前端微服务/微前端服务 就诞生了，简称其为微前端。

### 2. 微前端概念

微前端的概念是由 ThoughtWorks 在 2016 年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。

它主要解决了两个问题：

* 随着项目迭代应用越来越庞大，难以维护。
* 跨团队或跨部门协作开发项目导致效率低下的问题。

![微前端](https://img13.360buyimg.com/imagetools/jfs/t1/182098/24/20562/94562/6123569cE7a4b5bc3/f135ab0912746bd6.png)

### 3. 微前端特点

微前端就是将大而恐怖的东西切成更小、更易于管理的部分，然后明确地表明它们之间的依赖性。我们的技术选择，我们的代码库，我们的团队以及我们的发布流程都应该能够彼此独立地操作和发展，无需过多的协调。具体的特点如下：

#### 3.1 增量升级

对于许多团队而言，这是开始微前端之旅的首要原因。技术债阻碍了项目的发展，只能重写。为了避免完全重写的风险，我们更希望 逐个替换旧的模块。

#### 3.2 简单、解耦的代码库

每个单独的微型前端应用的源代码都将比单个整体前端应用的源代码少得多。这些较小的代码库对于开发人员来说更容易维护。尤其是我们避免了组件间耦合所导致的复杂性。

#### 3.3 独立部署

就像微服务一样，微前端的独立部署能力是关键。部署范围的减小，带来了风险的降低。每个微前端应用都应具有自己的持续交付途径，不停地构建、测试、部署。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/25/16d668cfcd5297bf\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

#### 3.4 团队自治

每个团队需要围绕业务功能垂直组建，而不是根据技术能力来组建。这为团队带来了更高的凝聚力。\


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/25/16d668e822d758f6\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 4. 微前端方案

单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似 Nginx 配置不同应用的转发，或是采用 iframe 来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：

| 方案             | 描述                                                                                                       | 优点                          | 缺点                                                  |
| -------------- | -------------------------------------------------------------------------------------------------------- | --------------------------- | --------------------------------------------------- |
| Nginx路由转发      | 通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。 | 简单，快速，易配置                   | 在切换应用时会触发浏览器刷新，影响体验                                 |
| iframe嵌套       | 父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式                                           | 实现简单，子应用之间自带沙箱，天然隔离，互不影响    | iframe的样式显示、兼容性等都具有局限性；太过简单而显得low                   |
| Web Components | 每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式                                                                | 每个子应用拥有独立的script和css，也可单独部署 | 对于历史系统改造成本高，子应用通信较为复杂易踩坑                            |
| 组合式应用路由分发      | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制                                                            | 纯前端改造，体验良好，可无感知切换，子应用相互隔离   | 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点 |

上述方案中，每种都有自己的优劣，最原始的 Nginx 配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而 iframe 嵌套是最简单和最快速的方案，但是 iframe 的弊端也是无法避免的，而Web Components 的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。

### 5. 微前端架构

基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示： &#x20;

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/1721766ee9a543cf\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

当整个微前端框架运行之后，给用户的体验就是类似下图所示：&#x20;

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/172176876d3a64fa\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的。

## 三、微前端核心

可以发现，微前端架构的优势，正是 `MPA` 与 `SPA` 架构优势的合集。即保证应用具备独立开发权的同时，又有将它们整合到一起保证产品完整的流程体验的能力。

`Stitching layer` 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：**导航路由 + 资源加载框架**。

而具体要实现这样一套架构，我们需要解决以下几个技术问题：

* **路由管理**
* **隔离机制**
* **消息通信**
* **依赖管理**

下面针对这些问题来一一阐述。

### 1. 路由管理

作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：

1. 作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要**远程拉取机制**。
2. 远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。
3. 当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考[import-html-entry](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fimport-html-entry)和[system.js](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsystem.js)。

对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：

1. 当浏览器的路径变化后，vue-router 会监听 hashchange 或者 popstate 事件，从而获取到路由切换的时机。
2. 最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。

### 2. 应用隔离

应用隔离问题主要需要考虑 JavaScript 执行环境隔离和 CSS 样式隔离。

#### 2.1 CSS 隔离

当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，可以采取以下两种方案

* CSS Module
* 命名空间，通过 webpack 的 postcss 插件，在打包时添加特定的前缀，即各个子应用使用特定的前缀来命名 class。但对于一些插入到 body 中的样式，比如 element UI 的 Popover 弹出框，这种就特殊处理

而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。

#### 2.2 JavaScript 隔离

每当微应用的 JavaScript 被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如 jQuery 这个 js 运行后，会在 Window 上挂载一个 window.$ 对象，对于其他库 React，Vue 也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。

沙箱机制的核心是让局部的 JavaScript 运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在 Node.js 端可以采用 vm 模块，而对于浏览器，则需要结合 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。

### 3. 消息通信

微前端通常不会限制应用采用的框架，如何在不同的应用，框架之间进行通信是一个需要仔细考量的决定。应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。

#### 3.1 自定义事件

通过[事件](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCustomEvent)进行通信应该是最简单、通用的方案了

```js
// 监听事件
window.addEventListener('message', (event) => {
  // 处理事件
});

// 触发事件
window.dispatchEvent(new CustomEvent('message', { detail: input.value }))
```

#### 3.2 发布-订阅

消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制

```js
import { Observable } from 'windowed-observable';

const observable = new Observable('konoha');
observable.subscribe((ninja) => {
  console.log(ninja)
})

observable.publish('Uchiha Shisui');
```

#### 3.3 Web Workers

通过 Web Workers 进行事件通信

```js
import Worky from 'worky'
const worker = new Worky("some-worker.js");

worker.on("eventName", function (some, data) {
  // 处理
});
worker.emit("someEvent", and, some, data);
```

#### 3.4 共享状态

主应用创建 state store，共享给子应用使用，适用于主、子应用技术栈相同的场景。

### **4. 依赖管理**

常见的微前端框架中，基座应用统一对子应用的状态进行管理。根据路由和子应用状态，按需触发生命周期函数，做请求加载、渲染、卸载等动作。而多个子应用间可能存在一些公共库的依赖。

为减少这类资源的重复加载，通常可以借助 webpack5 的 Module Federation 在构建时进行公共依赖的配置，实现运行时依赖共享的能力。除了使用打包工具的能力，也可以从代码层面通过实现类 external 功能对公共依赖进行管理。

## 四、微前端发展

### 1. 微前端框架

基于上述对微前端整体概念和理论的阐述，目前业界已经有不少框架来帮助开发者轻松的集成微前端架构，例如下面这些：

* [Mooa](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fmooa)：基于Angular的微前端服务框架
* [Single-Spa](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsingle-spa)：最早的微前端框架，兼容多种前端技术栈。
* [Qiankun](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fqiankun)：基于Single-Spa，阿里系开源微前端框架。
* [Icestark](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ficestark)：阿里飞冰微前端框架，兼容多种前端技术栈。
* [Ara Framework](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhttps%3A%2F%2Fara-framework.github.io%2Fwebsite%2Fdocs%2Fquick-start)：由服务端渲染延伸出的微前端框架。
* [Nx](https://nx.dev/)

上面这些框架，笔者这里就不在过多延伸，各位读者感兴趣的话可以来亲自试试。

### 2. 微前端使用场景

微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：

1. 微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。
2.  整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：

    1\)：基座应用和微应用的自动部署能力。

    2\)：微应用的配置管理能力。

    3\)：本地开发调试能力。

    4\)：线上监控和统计能力等等。

    只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。
3. 当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。

## 五、参考

* [最容易看懂的微前端知识](https://juejin.cn/post/6844904162509979662)
* [微前端入门](https://juejin.cn/post/6844903953734336525)
* [一文带你进入微前端世界](https://juejin.cn/post/7104253657251577886)
* [剑指前端 offer - 微前端](https://febook.hzfe.org/awesome-interview/book4/engineer-mfa)
