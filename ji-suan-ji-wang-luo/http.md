---
description: 超文本传输协议（Hyper Text Transfer Protocol，HTTP）
---

# HTTP

![HTTP 发展](<../.gitbook/assets/image (2).png>)

## 一、HTTP 头部信息

HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。

* 通用头：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。
* 请求头：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。&#x20;
* 响应头：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。&#x20;
* 实体头：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。

**通用首部**

| 通用字段              | 作用                             |
| ----------------- | ------------------------------ |
| Cache-Control     | 控制缓存的行为                        |
| Connection        | 浏览器想要优先使用的连接类型，比如 `keep-alive` |
| Date              | 创建报文时间                         |
| Pragma            | 报文指令                           |
| Via               | 代理服务器相关信息                      |
| Transfer-Encoding | 传输编码方式                         |
| Upgrade           | 要求客户端升级协议                      |
| Warning           | 在内容中可能存在错误                     |

**请求首部**

| 请求首部                | 作用                  |
| ------------------- | ------------------- |
| Accept              | 能正确接收的媒体类型          |
| Accept-Charset      | 能正确接收的字符集           |
| Accept-Encoding     | 能正确接收的编码格式列表        |
| Accept-Language     | 能正确接收的语言列表          |
| Expect              | 期待服务端的指定行为          |
| From                | 请求方邮箱地址             |
| Host                | 服务器的域名              |
| If-Match            | 两端资源标记比较            |
| If-Modified-Since   | 本地资源未修改返回 304（比较时间） |
| If-None-Match       | 本地资源未修改返回 304（比较标记） |
| User-Agent          | 客户端信息               |
| Max-Forwards        | 限制可被代理及网关转发的次数      |
| Proxy-Authorization | 向代理服务器发送验证信息        |
| Range               | 请求某个内容的一部分          |
| Referer             | 表示浏览器所访问的前一个页面      |
| TE                  | 传输编码方式              |

**响应首部**

| 响应首部               | 作用            |
| ------------------ | ------------- |
| Accept-Ranges      | 是否支持某些种类的范围   |
| Age                | 资源在代理缓存中存在的时间 |
| ETag               | 资源标识          |
| Location           | 客户端重定向到某个 URL |
| Proxy-Authenticate | 向代理服务器发送验证信息  |
| Server             | 服务器名字         |
| WWW-Authenticate   | 获取资源需要的验证信息   |

**实体首部**

| 实体首部             | 作用                   |
| ---------------- | -------------------- |
| Allow            | 资源的正确请求方式            |
| Content-Encoding | 内容的编码格式              |
| Content-Language | 内容使用的语言              |
| Content-Length   | request body 长度      |
| Content-Location | 返回数据的备用地址            |
| Content-MD5      | Base64加密格式的内容 MD5检验值 |
| Content-Range    | 内容的位置范围              |
| Content-Type     | 内容的媒体类型              |
| Expires          | 内容的过期时间              |
| Last\_modified   | 内容的最后修改时间            |

## 二、HTTP 方法

HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。

HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。

| 方法      | 描述                                                                    |
| ------- | --------------------------------------------------------------------- |
| GET     | 请求指定的页面信息，并返回具体内容，通常只用于读取数据。                                          |
| HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。                                   |
| POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。 |
| PUT     | 替换指定的资源，没有的话就新增。                                                      |
| DELETE  | 请求服务器删除 URL 标识的资源数据。                                                  |
| CONNECT | 将服务器作为代理，让服务器代替用户进行访问。                                                |
| OPTIONS | 向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。                                     |
| TRACE   | 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。                                 |
| PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新。                                           |

## 三、HTTP 状态码

HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，HTTP 状态码共有 5 种类型：

| 分类  | 描述                                |
| --- | --------------------------------- |
| 1XX | 指示信息 - 表示请求正在处理                   |
| 2XX | 成功 - 表示请求已被成功处理完毕                 |
| 3XX | 重定向 - 要完成的请求需要进行附加操作              |
| 4XX | 客户端错误 - 请求有语法错误或者请求无法实现，服务器无法处理请求 |
| 5XX | 服务器端错误 - 服务器处理请求出现错误              |

相应的 HTTP 状态码列表：

| 状态码 | 英文                              | 描述                                                                            |
| --- | ------------------------------- | ----------------------------------------------------------------------------- |
| 100 | Continue                        | 继续。客户端继续处理请求                                                                  |
| 101 | Switching Protocol              | 切换协议。服务器根据客户端的请求切换到更高级的协议                                                     |
| 200 | OK                              | 请求成功。请求所希望的响应头或数据体将随此响应返回                                                     |
| 201 | Created                         | 请求以实现。并且有一个新的资源已经依据需求而建立                                                      |
| 202 | Accepted                        | 请求已接受。已经接受请求，但还未处理完成                                                          |
| 203 | Non-Authoritative Information   | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器中，而是一个副本                                       |
| 204 | No Content                      | 无内容。服务器成功处理了请求，但不需要返回任何实体内容                                                   |
| 205 | Reset Content                   | 重置内容。与 204 类似，不同点是返回此状态码的响应要求请求者重置文档视图                                        |
| 206 | Partial Content                 | 部分内容。服务器成功处理了部分 GET 请求                                                        |
| 300 | Multiple Choices                | 多种选择。被请求的资源有一系列可供选择的回馈信息，用户或浏览器能够自行选择一个首选地址进行重定向                              |
| 301 | Moved Permanently               | 永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI                          |
| 302 | Found                           | 临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI                                        |
| 303 | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看                                                  |
| 304 | Not Modified                    | 未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码 |
| 305 | Use Proxy                       | 使用代理。被请求的资源必须通过指定的代理才能被访问                                                     |
| 306 | Unused                          | 在最新版的规范中，306状态码已经不再被使用                                                        |
| 307 | Temporary Redirect              | 临时重定向。请求的资源现在临时从不同的URI 响应请求，与302类似                                            |
| 400 | Bad Request                     | 客户端请求的语法错误，服务器无法理解；请求的参数有误                                                    |
| 401 | Unauthorized                    | 当前请求需要用户验证                                                                    |
| 402 | Payment Required                | 该状态码是为了将来可能的需求而预留的                                                            |
| 403 | Forbidden                       | 服务器已经理解请求，但是拒绝执行它                                                             |
| 404 | Not Found                       | 请求失败，请求所希望得到的资源未被在服务器上发现                                                      |
| 405 | Method Not Allowed              | 客户端请求中的方法被禁止                                                                  |
| 406 | Not Acceptable                  | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体                                              |
| 407 | Proxy Authentication Required   | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证                                                |
| 408 | Request Time-out                | 请求超时。服务器等待客户端发送的请求时间过长，超时                                                     |
| 409 | Conflict                        | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成                                                   |
| 410 | Gone                            | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址                                               |
| 411 | Length Required                 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求                                           |
| 412 | Precondition Failed             | 客户端请求信息的先决条件错误                                                                |
| 413 | Request Entity Too Large        | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围                                   |
| 414 | Request-URI Too Large           | 请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务                                       |
| 415 | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                                                              |
| 416 | Requested range not satisfiable | 客户端请求的范围无效                                                                    |
| 417 | Expectation Failed              | 服务器无法满足Expect的请求头信息                                                           |
| 500 | Internal Server                 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理                                                |
| 501 | Not Implemented                 | 服务器不支持当前请求所需要的某个功能                                                            |
| 502 | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应                                          |
| 503 | Service Unavailable             | 由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常                                        |
| 504 | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求                                                     |
| 505 | HTTP Version not supported      | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本                                                  |

## 四、HTTP 1.X

HTTP 1.1 和 HTTP 1.0 的主要区别如下：

* **缓存处理**：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持**更为灵活的缓存策略**，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。
* **节约带宽**： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中**引入了 range 头域**，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现**高效并发**。
* **错误通知的管理**：HTTP/1.1 在 1.0 的基础上**新增了 24 个错误状态响应码**，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。
* **Host 请求头**：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了**支持虚拟主机**，HTTP/1.1 中**添加了 host 请求头**，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。
* **长连接**：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 **默认使用的是持久连接**，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。

## 五、HTTP 2.0

HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。

### 1. 二进制传输

HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

![HTTP 2.0 二进制传输](<../.gitbook/assets/image (6) (1).png>)

### 2. 多路复用

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

![](<../.gitbook/assets/image (3).png>)

### 3. Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

### 4. 服务端 Push

在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。

例如，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

## 六、HTTP 3.0

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。

传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP/2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。此外，HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。

### 1. QUIC 协议

QUIC（Quick UDP Internet Connections），直译为快速 UDP 网络连接，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP/2 等协议的特性，并基于 UDP传输。该协议带来的主要提升有：

* 低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。
* QUIC 复用了 HTTP/2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2存在的队头阻塞问题。
* 基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。
* QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。
* 具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。

### 2. HTTP 3.0 内容

HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。

HTTP/3 主要有以下几个特点：

* 使用 UDP 作为传输层进行通信；
* 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；
* 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；
* 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；
* 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。

## 七、考点

### 1. HTTP 长连接和短连接

这篇[文章](https://blog.csdn.net/luzhensmart/article/details/87186401)解释的很详细。总结如下：

* **长连接**是指建立一次 TCP 连接能够维持较长时间，不需要每次请求都发起 TCP 连接；
* **短连接**是指每次请求都需要重新建立 TCP 连接；
* 长连接是通过设置 **Connection 为 keep-alive** 实现的，HTTP 1.1 开始默认的，需要客户端和服务端都支持；
* 长连接和短连接都是**基于 TCP 连接**，HTTP 本身无法维持长连接；
* 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况；
* 短连接通常用于用户量很大的网站，避免耗费太多服务端资源；

### 2. HTTP 头部内容

详情见[上文](http.md#http-tou-bu-xin-xi)，区分如下：

* **通用头**：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如 Cache-Control, Connection, Date, Transfer-Encoding 等。&#x20;
* **请求头**：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如 Accept, Accept-Encoding, Accept-Language, Host, Referer, If-Match, User-Agent 等。&#x20;
* **响应头**：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如 Server, Age, ETag, Location, Accept-Ranges 等。
* **实体头**：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如 Allow, Content-Type, Content-Encoding, Content-Length, Expires 等。

### 3. GET 和 POST 的区别

常见的区别如下：

* get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。&#x20;
* get 请求只支持 URL 编码，post 请求支持多种编码格式。
* get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。
* get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制&#x20;
* get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。&#x20;
* get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。

> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。
>
> 对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。

| 操作   | 数据位置    | 明文密文 | 数据安全 | 长度限制        | 应用场景 |
| ---- | ------- | ---- | ---- | ----------- | ---- |
| GET  | HTTP 包头 | 明文   | 不安全  | 长度较小，受浏览器限制 | 查询数据 |
| POST | HTTP 正文 | 可明可密 | 安全   | 支持较大数据传输    | 修改数据 |

### 4. 常见的 HTTP 状态码

详情见[上文](http.md#http-zhuang-tai-ma)，常见及需要记住的如下：

* 200 请求成功
* 204 请求成功但无内容返回
* 301 永久重定向
* 30(2|3|7) 临时重定向，语义和实现有略微区别
* 304 带if-modified-since 请求首部的条件请求，条件没有满足
* 400 语法错误（前端挨打）
* 401 需要认证信息&#x20;
* 403 拒绝访问，通常是权限不够
* 404 找不到资源
* 412 除if-modified-since 以外的条件请求，条件未满足
* 500 服务器错误（后端挨打）
* 501 服务器不支持当前请求所需要的某个功能
* 503 服务器宕机了（DevOps or IT 挨打）

要能区分**401和403**，以及**301和302**。

### 5. HTTP 1.1 和 HTTP 1.0 的区别

详情见[上文](http.md#undefined)，归纳总结为五点：

* 长短连接（keep-alive、基于tcp、应用场景）；
* 缓存策略（更加灵活、增加）；
* 节约带宽（range头域请求部分资源）；
* 错误消息管理（增加24）；
* host请求头（ip、虚拟主机）；

### 6. HTTP 2.0 vs HTTP 1.X

详情见[上文](http.md#http-2.0)，总结如下：

* **二进制传输**：之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式
* **多路复用**：1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）；2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响
* **header压缩**：每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，减少了传输的数据量
* **服务端推送**：服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了

### 7. HTTP 3.0 vs HTTP 2.0

详情见上文，主要是 QUIC 的特点：

* 减少往返次数RTT,缩短连接建立时间⌚️： 缓存对方的信息
* 连接多路复用，且采用独立数据流避免丢包阻塞
* 使用前行纠错恢复丢失的包，减少超时重传
* 连接保存连接标志符，网络迁移连接快\
