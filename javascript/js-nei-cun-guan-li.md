# JS 内存管理

## 一、引言

对于像 C 这样的编程语言，有 `malloc()` 和 `free()` 这样的基础内存管理函数。开发人员可以使用这些函数来显式分配和释放来操作系统的内存。

与此同时，JavaScrip 在对象被创建时分配内存，并在对象不再使用时“自动”释放内存，这个过程被称为垃圾回收。这种看似“自动”释放资源的特性是导致混乱的来源，它给了 JavaScript 开发者们一种错觉，他们可以选择不去关心内存管理。**这是一种错误的观念。**

即使使用高级语言，开发者也应该对内存管理有一些理解。有时，自动内存管理存在的问题（比如垃圾回收器的错误或内存限制等）要求开发者需要理解内存管理，才能处理的更合适。

## **二、内存**

### **1. 内存生命周期**

无论你使用哪种程序语言，内存生命周期总是大致相同的：

* **内存分配** — 内存由操作系统分配，它允许你的应用程序使用。在基础语言中 (比如 C 语言)，这是一个开发人员应该处理的显式操作。然而在高级系统中，语言已经帮你完成了这些工作。
* **内存使用** — 这是你的程序真正使用之前分配的内存的时候，**读写**操作在你使用代码中已分配的变量时发生。
* **内存释放** — 释放你明确不需要的内存，让其再次空闲和可用。和**内存分配**一样，在基础语言中这是显式操作。

![内存生命周期](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/4/16021e61fc193b5d\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### **2. 内存工作原理**

在直接跳到有关 JavaScript 中的内存部分之前，我们将简要地讨论一下内存的概况以及它是如何工作的：

在硬件层面上，内存包含大量的[触发器](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFlip-flop\_%2528electronics%2529)。每一个触发器包含一些晶体管并能够存储一位。单独的触发器可通过**唯一标识符**寻址, 所以我们可以读取和覆盖它们。因此，从概念上讲，我们可以把整个计算机内存看作是我们可以读写的一个大的位组。

作为人类，我们并不擅长在位操作中实现我们所有的思路和算法，我们把它们组装成更大的组，它可以用来表示数字。8 位称为 1 个字节。除字节外，还有单词（有时是 16，有时是 32 位）。

很多东西存储在内存中:

1. 所有程序使用的所有变量和其他数据。
2. 程序的代码，包括操作系统的代码。

编译器和操作系统一起为您处理了大部分的内存管理，但是我们建议您看看底层发生了什么。

#### 静态分配

当你编译代码时，编译器可以检查原始数据类型，并提前计算它们需要多少内存。然后所需的数量被分配给**栈空间**中的程序。分配这些变量的空间称为栈空间，因为随着函数被调用，它们的内存被添加到现有的内存之上。当它们终止时，它们以 LIFO（后进先出）顺序被移除。 例如，请考虑以下声明：

```
int n; // 4 bytes
int x[4]; // array of 4 elements, each 4 bytes
double m; // 8 bytes
```

编译器可以立即计算到代码需要 4 + 4 × 4 + 8 = 28 bytes。

> 这是它处理 integers 和 doubles 类型当前大小的方式。大约 20 年前，integers 通常是 2 个字节，doubles 通常是 4 个字节。您的代码不应该依赖于某一时刻基本数据类型的大小。

编译器将插入与操作系统交互的代码，为堆栈中的变量请求存储所需的字节数。

在上面的例子中，编译器知道每个变量的具体内存地址。 事实上，只要我们写入变量 `n`，它就会在内部被翻译成类似“内存地址 4127963”的内容。

注意，如果我们试图在这里访问 `x[4]`，我们将访问与 m 关联的数据。这是因为我们正在访问数组中不存在的一个元素 - 它比数组中最后一个实际分配的元素 `x[3]` 深了 4 个字节，并且最终可能会读取（或覆盖）一些 `m` 的位。这对项目的其余部分有预料之外的影响。

![内存分配](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/4/16021e62014a770d\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

当函数调用其他函数时，每个其他函数调用时都会产生自己的栈块。栈块保留了它所有的局部变量和一个记录了执行地点程序计数器。当函数调用完成时，其内存块可再次用于其他方面。

#### **动态分配**

遗憾的是，当我们不知道编译时变量需要多少内存时，事情变得不再简单。假设我们想要做如下的事情：

```
int n = readInput(); // reads input from the user
...
// create an array with "n" elements
```

这里，在编译时，编译器不知道数组需要多少内存，因为它是由用户提供的值决定的。

因此，它不能为堆栈上的变量分配空间。相反，我们的程序需要在运行时明确地向操作系统请求正确的内存量。这个内存是从**堆空间**分配的。下表总结了静态和动态内存分配之间的区别：

![静态和动态内存分配的区别](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/4/16021e62028423d2\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

## 二、JS 中的内存模型

JS 内存空间可以分为**栈(stack)**、**堆(heap)**、**池(一般也会归类为栈中)**。 其中**栈**存放变量，**堆**存放复杂对象，**池**存放常量。

我们都知道，JS 的数据类型分为两种：**基本数据类型** 和 **引用数据类型**。类型不同，数据存放的位置自然也不同：

* **基本数据类型的数据是存放在栈空间中的；**
* **引用数据类型的数据是存放在堆空间中的；**

来看看下面这些数据都是怎么存储的：

```javascript
function test() {
  var a = '起风了';
  var b = a;
  b = "心动了";
  var c = { "name": "婷婷" };
  var d = c;
  d.name = "瑶瑶";
  console.log(c.name); // "瑶瑶"
}
test();
```

这里的栈空间其实就是 **调用栈，是用来存储执行上下文的**。当执行一段代码时，需要先编译，创建执行上下文，然后再按照顺序执行代码。

### 1. 基本数据类型

当以上代码执行到第 4 行时，调用栈的状态如下所示：

![基本数据类型存放](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ff096a64a84d4a8dbf4956d746333a\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

从图中可以看出来，当代码执行到第 4 行时，变量 `a` 和变量 `b` 的 **变量值** 都被保存在执行上下文中，而执行上下文又被压入到调用栈中，所以也可以认为变量 `a` 和变量 `b` 的值都是存放在调用栈中。而当变量 `b` 修改变量值时，修改的仅仅是它本身的值，并不会影响到变量 `a` 的值。

所以：

* **基本数据类型的值直接存储在栈空间中；**
* **基础数据类型的值与值之间是独立存在的，修改一个变量不会影响其它变量；**

### 2. 引用数据类型

当执行到第 5 行代码时，由于 JS 引擎判断变量 `c` 右边的值是一个引用类型，然后将它分配到堆空间里面，分配后该对象会有一个在 **堆空间中的地址**，然后再将该数据的地址写进 `c` 的变量值，此时内存的示意图如下所示：

![引用数据类型存放](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2835140290a42e6863e04cb55687942\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

当执行第 6 行代码（`var d = c;`）时，其实是把变量 `c` 的引用地址（`1001`）赋给变量 `d`，所以当执行完第 7 行代码后，内存的示意图如下：

![引用类型赋值](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25dbb34d6374492a9d15199f91f6386b\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

在 JS 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。因为变量 `c` 和变量 `d` 是同一个引用，所以修改变量 `d` 其实是修改引用地址指向的对象数据，在最后变量 `c` 打印 `c.name` 的值是 `瑶瑶`。

即：

* **引用数据类型的数据是保存到堆空间中的，每创建一个新的对象，就会在堆空间中开辟一个新的空间；**
* **变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个变量修改属性时，另一个也会受到影响；**

## 三、JS 中内存生命周期

### **1. 内存分配**

现在我们将解释第一步（**分配内存**）是如何在JavaScript中工作的。

JavaScript 减轻了开发人员处理内存分配的责任 - JavaScript自己执行了内存分配，同时声明了值。

```javascript
var n = 374; // allocates memory for a number
var s = 'sessionstack'; // allocates memory for a string 
var o = {
  a: 1,
  b: null
}; // allocates memory for an object and its contained values
var a = [1, null, 'str'];  // (like object) allocates memory for the
                           // array and its contained values
function f(a) {
  return a + 3;
} // allocates a function (which is a callable object)
// function expressions also allocate an object
someElement.addEventListener('click', function() {
  someElement.style.backgroundColor = 'blue';
}, false);
```

一些函数调用也会导致对象分配：

```javascript
var d = new Date(); // allocates a Date object

var e = document.createElement('div'); // allocates a DOM element
```

方法可以分配新的值或对象：

```javascript
var s1 = 'sessionstack';
var s2 = s1.substr(0, 3); // s2 is a new string
// Since strings are immutable, 
// JavaScript may decide to not allocate memory, 
// but just store the [0, 3] range.
var a1 = ['str1', 'str2'];
var a2 = ['str3', 'str4'];
var a3 = a1.concat(a2); 
// new array with 4 elements being
// the concatenation of a1 and a2 elements
```

### **2. 使用内存**

基本上在 JavaScript 中使用分配的内存，意味着在其中读写。

这可以通过读取或写入变量或对象属性的值，甚至传递一个变量给函数来完成。

### **3. 释放内存**

内存管理最困难的任务是确定何时不再需要这些分配了的内存。它通常需要开发人员确定程序中的哪个部分不再需要这些内存，并将其释放。

具体的 JS 垃圾回收机制在下一节单独讨论。

## **四、JS 垃圾回收**

在计算机科学中，**垃圾回收**（英语：Garbage Collection，缩写为GC）是一种自动的内存管理机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，称为垃圾回收。

换句话说，**不再使用的数据称为垃圾数据，需要对这些数据进行回收以释放有限的内存空间**。如果有一段数据已经不再使用，但是又没有被销毁回收空间，那么这种情况就被称为 **内存泄漏**。

垃圾回收有两种策略，分别是：

* **手动回收策略**：何时分配内存、何时销毁内存都是由代码控制的，如 C、C++ 等语言。
* **自动回收策略**：产生的垃圾数据是由垃圾回收器来释放回收的，并不需要手动通过代码来释放。如 JavaScript、Java、Python 等语言。

对于 JS 而言，也正是这个自动释放资源的特性带来了很多困惑，也让一些 JS 开发者误以为可以不关心内存管理，这是一个很大的误解。

### 1. 栈空间的垃圾回收

栈空间即调用栈，栈它是有一个先入后出的特性，调用栈亦是如此。

* 在调用栈中会有一个 **记录当前执行状态的指针（称为 ESP ）**，指向调用栈中正在执行函数 A 的执行上下文，表示当前正在执行 A 函数。
* 当 A 函数执行完成后会进入 B 函数，这时 JS 会将 ESP 下移到 B 函数，这个 ESP 下移操作就是销毁 A 函数执行上下文的过程
* 当 A 函数执行结束之后， ESP 向下移动到 B 函数的执行上下文中，上面 A 函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 B 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9220979bee984c63b5ab04ed1759c31b\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

即 **当一个函数执行结束之后，JS 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**，简单来说，当函数执行完成之后，它对应的执行上下文已经不会再用了，在执行上下文里面的变量自然也会被回收。

### 2. 堆空间的垃圾回收

相对于栈空间来说，堆空间回收数据会复杂很多，要回收堆空间中的垃圾数据，会用到 JS 引擎中的垃圾回收器。这里的 JS 引擎还是指 V8，而 V8 的垃圾回收策略是建立在代际假说的基础上的，所以先来了解一下代际假说。

#### **代际假说**

代际假说有以下两个特点：

* **大部分对象在内存中存在的时间很短**，简单来说，就是很多对象一经分配内存，很快就会变得不可访问；
* **不死的对象，会活得更久**。

#### **分代收集**

通常，垃圾回收算法有很多种，但是 **并没有哪一种能胜任所有的场景，需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果**。

在 V8 中会把堆分为新生代和老生代两个区域：

* 顾名思义，**新生代中存放的是生存时间短的对象**；通常只支持 1～8M 的容量
* **老生代中存放的生存时间久的对象和占用空间大的对象**；支持的容量会大很多

对于这两块区域，V8 会分别使用两个不同的垃圾回收器，其中 **新生代的垃圾主要用副垃圾回收器来回收**；**老生代的垃圾主要用主垃圾回收器来回收**，以便更高效地实施垃圾回收。

![V8 的堆空间](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e0c38a664bf40408d4b62f5452e3582\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

#### **垃圾回收器的工作流程**

不论什么类型的垃圾回收器，基本上它们都有一套共同的执行流程。

* 第一步是 **标记空间中活动对象和非活动对象**。
  * 所谓活动对象就是还在使用的对象
  * 非活动对象就是可以进行垃圾回收的对象
* 第二步是 **回收非活动对象所占据的内存**。
  * 即在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
* 第三步是 **做内存整理**。
  * 一般来说，频繁回收对象后，内存中会存在一些不连续的空间，这些不连续的内存空间被称为 **内存碎片**，当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。
  * 不过这一步其实是可选的，因为像副垃圾回收器（新生区）就不会产生内存碎片，自然也不用做内存整理。

#### **新生区的垃圾回收**

**新生区的垃圾主要由副垃圾回收器来回收**。一般情况下，大多数小的对象都会被分配到新生区，这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域（From），一半是空闲区域（To），如上图所示。

新加入的对象都会存放到 **对象区域**，当对象区域快被写满时，就需要执行一次垃圾清理操作。过程如下：

* 在垃圾回收过程中，首先要 **对对象区域中的垃圾做标记**。
* 标记完成之后，就进入 **垃圾清理** 阶段，副垃圾回收器 **把这些存活的对象复制到空闲区域中**
  * 同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了 **内存整理** 操作，复制后空闲区域就没有内存碎片了。
* 完成复制后，**对象区域与空闲区域进行角色翻转**。
  * 即原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

简单来说，就是**将新生区分为两个大小相同的区域，然后利用对象区域进行分配，当对象区域满的时候，副垃圾回收器将其中的活动对象复制到空闲区域，之后将两个空间互换即完成一次垃圾回收**。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以 **为了执行效率，一般新生区的空间会被设置得比较小**。

正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JS 引擎采用了 **对象晋升策略**，也就是 **经过两次垃圾回收依然还存活的对象，会被移动到老生区中**。

新生区垃圾回收的优点如下：

* 具有优秀的吞吐量，只需要关心活动对象
* 可实现高速分配，因为分块是连续的，不需要使用空闲链表
* 不会发生碎片化
* 与缓存兼容

缺点：

* 堆使用率低
* 与保守式GC不兼容
* 递归调用函数，制子对象需要递归调用复制函数

#### **老生区的垃圾回收**

**老生区中的垃圾主要由主垃圾回收器来负责回收**。除了新生区中晋升的对象，一些大的对象也会直接被分配到老生区。

所以老生区中的对象会有以下两个特点：它要么是 **对象占用空间大**，要么是 **对象存活时间长**，或者两者兼有之。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，**主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的**。

**标记-清除算法**

**标记-清除** 回收的过程如下：

* 首先是 **标记过程阶段**。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，**能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据**。
* 接下来是 **垃圾的清除过程**。它和副垃圾回收器的垃圾清除过程不同，它是直接把垃圾数据清除的，因此会产生大量不连续的内存碎片。

标记-清除算法的优点是实现简单，比较容易和其他算法组合；但是也有一些缺点，如下：

* 碎片化，会产生大量不连续的内存碎片
* 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
* 与写时复制技术不兼容，因为每次都会在活动对象上打上标记

**标记-整理算法**

对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片；而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 **标记-整理（Mark-Compact）算法**。

标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是 **让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存**，这样消除了内存碎片。但是这个整理是需要花费计算成本的，标记后需要定位各个活动对象的新内存地址，然后再移动对象，总共搜索了 3 次堆。

* 优点：有效利用了堆，不会出现内存碎片，也不会像复制算法那样只能利用堆的一部分
* 缺点：整理过程开销会变大，需要多次搜索堆

**全停顿**

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做 **全停顿（Stop-The-World）**。

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，在垃圾回收的这段时间（比如200ms）内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

**增量标记算法**

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的 **子标记过程**，同时**让垃圾回收标记和 JavaScript 应用逻辑交替进行**，直到标记阶段完成，这个算法称为**增量标记（Incremental Marking）算法**。

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

## 五、JS 内存泄漏

就像内存描述的那样，**内存泄漏**是应用程序过去使用但不再需要的尚未返回到操作系统或可用内存池的内存片段。

![Memory Leak](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/4/16021e626dd93eb1\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

编程语言偏好不同的内存管理方式。但是，某段内存是否被使用实际上是一个不可判定问题。换句话说，只有开发人员可以明确某块内存是否可以返回给操作系统。

JavaScript 中有以下几种常见的内存泄漏：

### **1. 全局变量**

JavaScript 用一种有趣的方式处理未声明的变量：当引用一个未声明的变量时，在 _global_ 对象中创建一个新变量。在浏览器中，全局对象将是 `window`，这意味着

```
function foo(arg) {
    bar = "some text";
}
```

等同于:

```
function foo(arg) {
    window.bar = "some text";
}
```

我们假设 `bar` 的目的只是引用 foo 函数中的一个变量。然而，如果你不使用 `var` 来声明它，就会创建一个冗余的全局变量。在上面的情况中，这不会造成很严重的后果。你可以想象一个更具破坏性的场景。

你也可以用 `this` 意外地创建一个全局变量：

```
function foo() {
    this.var1 = "potential accidental global";
}
// Foo called on its own, this points to the global object (window)
// rather than being undefined.
foo();
```

> 你可以通过在 JavaScript 文件的开头添加 `'use strict';` 来避免这些后果，这将开启一种更严格的 JavaScript 解析模式，从而防止意外创建全局变量。

意外的全局变量当然是个问题，然而更常出现的情况是，你的代码会受到显式的全局变量的影响，而这些全局变量无法通过垃圾收集器收集。需要特别注意用于临时存储和处理大量信息的全局变量。如果你必须使用全局变量来存储数据，当你这样做的时候，要保证一旦完成使用就把他们**赋值为 null 或重新赋值** 。

### **2. 定时器或回调函数**

我们以经常在 JavaScript 中使用的 `setInterval` 为例。

提供观察者和其他接受回调的工具库通常确保所有对回调的引用在其实例无法访问时也变得无法访问。然而，下面的代码并不鲜见：

```
var serverData = loadData();
setInterval(function() {
    var renderer = document.getElementById('renderer');
    if(renderer) {
        renderer.innerHTML = JSON.stringify(serverData);
    }
}, 5000); //This will be executed every ~5 seconds.
```

上面的代码片段显示了使用定时器引用节点或无用数据的后果。

`renderer` 对象可能会在某些时候被替换或删除，这会使得间隔处理程序封装的块变得冗余。如果发生这种情况，处理程序及其依赖项都不会被收集，因为间隔处理需要先备停止（请记住，它仍然是活动的）。这一切都归结为一个事实，即事实存储和处理负载数据的 `serverData` 也不会被收集。

当使用观察者时，你需要确保一旦依赖于它们的事务已经处理完成，你编写了明确的调用来删除它们（不再需要观察者，或者对象将变得不可用时）。

幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当观察对象变得无法访问时，它们也会自动收集观察者处理程序。过去一些浏览器无法处理这些情况（旧的 IE6）。

但是，尽管如此，一旦对象变得过时，移除观察者才是符合最佳实践的。看下面的例子：

```
var element = document.getElementById('launch-button');
var counter = 0;
function onClick(event) {
   counter++;
   element.innerHtml = 'text ' + counter;
}
element.addEventListener('click', onClick);
// Do stuff
element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
// Now when element goes out of scope,
// both element and onClick will be collected even in old browsers // that don't handle cycles well.
```

现在的浏览器支持检测这些循环并适当地处理它们的垃圾收集器，因此在制造一个无法访问的节点之前，你不再需要调用 `removeEventListener`。

如果您利用 `jQuery` API（其他库和框架也支持这个），您也可以在节点废弃之前删除监听器。即使应用程序在较旧的浏览器版本下运行，这些库也会确保没有内存泄漏。

### 3. 闭包

JavaScript开发的一个关键方面是闭包：一个内部函数可以访问外部（封闭）函数的变量。由于JavaScript运行时的实现细节，可能以如下方式泄漏内存：

```
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing) // a reference to 'originalThing'
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log("message");
    }
  };
};
setInterval(replaceThing, 1000);
```

一旦调用了 `replaceThing` 函数，`theThing` 就得到一个新的对象，它由一个大数组和一个新的闭包（`someMethod`）组成。然而 `originalThing` 被一个由 `unused` 变量（这是从前一次调用 `replaceThing` 变量的 `Thing` 变量）所持有的闭包所引用。需要记住的是**一旦为同一个父作用域内的闭包创建作用域，作用域将被共享。**

在个例子中，`someMethod` 创建的作用域与 `unused` 共享。`unused` 包含一个关于 `originalThing` 的引用。即使 `unused` 从未被引用过，`someMethod` 也可以通过 `replaceThing` 作用域之外的 `theThing` 来使用它（例如全局的某个地方）。由于 `someMethod` 与 `unused` 共享闭包范围，`unused` 指向 `originalThing` 的引用强制它保持活动状态（两个闭包之间的整个共享范围）。这阻止了它们的垃圾收集。

在上面的例子中，为闭包 `someMethod` 创建的作用域与 `unused` 共享，而 `unused` 又引用 `originalThing`。`someMethod` 可以通过 `replaceThing` 范围之外的 `theThing` 来引用，尽管 `unused` 从来没有被引用过。事实上，unused 对 `originalThing` 的引用要求它保持活跃，因为 `someMethod` 与 unused 的共享封闭范围。

所有这些都可能导致大量的内存泄漏。当上面的代码片段一遍又一遍地运行时，您可以预期到内存使用率的上升。当垃圾收集器运行时，其大小不会缩小。一个闭包链被创建（在例子中它的根就是 `theThing` 变量），并且每个闭包作用域都包含对大数组的间接引用。

Meteor 团队发现了这个问题，[它们有一篇很棒的文章](https://link.juejin.cn/?target=https%3A%2F%2Fblog.meteor.com%2Fan-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)详细地描述了这个问题。

### **4. 超出 DOM 的引用**

有些情况下开发人员在数据结构中存储 DOM 节点。假设你想快速更新表格中几行的内容。如果在字典或数组中存储对每个 DOM 行的引用，就会产生两个对同一个 DOM 元素的引用：一个在 DOM 树中，另一个在字典中。如果你决定删除这些行，你需要记住让两个引用都无法访问。

```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image')
};
function doStuff() {
    elements.image.src = 'http://example.com/image_name.png';
}
function removeImage() {
    // The image is a direct child of the body element.
    document.body.removeChild(document.getElementById('image'));
    // At this point, we still have a reference to #button in the
    //global elements object. In other words, the button element is
    //still in memory and cannot be collected by the GC.
}
```

在涉及 DOM 树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（`td` 标记）的引用，并决定从 DOM 中删除该表格但保留对该特定单元格的引用，则可以预见到严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元格之外的所有东西。但情况并非如此。由于单元格是表格的子节点，并且子节点保持对父节点的引用，所以**对表格单元格的这种单引用会把整个表格保存在内存中**。

## 六、考点

### 1. 为什么一定要分栈空间和堆空间呢？

也许你会有这样一个疑问：为什么一定要分出来堆空间和栈空间两个内存空间呢？把数据都存放在栈空间里面不可以吗？

答案是不可以的，因为在 JS 中，**调用栈是用来维护程序执行期间执行上下文的状态的**，如果调用栈空间大了的话，所有的数据都存放在栈空间里面，那么就会影响到执行上下文切换的效率，然后影响到整个程序的执行效率。

为了不影响执行上下文切换的效率，栈空间一般会设置小一些，而因为引用类型的数据占用的空间又比较大，栈空间存放不下，所以会把引用类型的数据存放在堆空间中。

所以在一般情况下，**栈空间都不会设置太大，然后用来存放一些基本数据类型的数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

## 七、参考

* [JavaScript 工作原理：内存管理 + 处理常见的4种内存泄漏](https://juejin.cn/post/6844903519078580238)
* [JavaScript 的垃圾数据是怎么回收的](https://juejin.cn/post/6977388535418470413)
* [JavaScript 内存机制](https://juejin.cn/post/6844903615300108302)
* [你的程序中可能存在内存泄漏](https://juejin.cn/post/6984188410659340324)
* [内存空间详细图解](https://www.jianshu.com/p/996671d4dcc4)
