# JS 事件循环机制

## 一、引言

事件循环（Event Loop）是一个很重要的概念，指的是计算机系统的一种运行机制。JavaScript 语言就采用这种机制，来解决单线程运行带来的一些问题。

## 二、背景

### 1. JS 单线程原因

要理解事件循环，就要从程序的运行模式讲起。运行以后的程序叫做"进程"（process），一般情况下，一个进程一次只能执行一个任务。如果有很多任务需要执行，不外乎三种解决方法：

* 排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。
* 新建进程。使用 fork 命令，为每个任务新建一个进程。
* 新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。

以 JavaScript 语言为例，它是一种单线程语言，所有任务都在一个线程上完成，即采用上面的第一种方法。一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现"假死"，因为 JavaScript 停不下来，也就无法响应用户的行为。

作为浏览器脚本语言， **JavaScript 从诞生开始就是单线程**。原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。后来就约定俗成，**JavaScript 为一种单线程语言**。

JavaScript 是单线程语言大概还和它的用途有关。JavaScript 的主要用途是 **和用户互动，以及操作 DOM**。**这决定了它只能是单线程**，否则会带来很复杂的同步问题。比如，假如 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准呢？

而为了利用多核 CPU 的计算能力， HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是 **子线程完全受主线程控制，且不得操作 DOM**。所以，这个新标准并没有改变 JavaScript 单线程的本质。

### 2. JS 单线程执行

JavaScript 这个单线程是怎样处理任务的？

#### **2.1 处理安排好的任务**

这个场景比较简单，将这些任务代码按照顺序写进主线程里，等线程执行时，这些任务就是**按照顺序在线程中依次被执行**；等所有任务执行完成之后，线程会自动退出。

#### **2.3 处理线程运行过程中产生的新任务**

并不是所有的任务都是在执行之前就可以安排好的，大部分情况下，**新的任务会在线程运行过程中不断产生**。要想在线程运行过程中，能接收并执行新的任务，就需要用到 **事件循环机制** 了。

相较于处理安排好的线程任务，如果要处理新的任务，这个单线程需要做以下改进：

* 第一点引入了 **循环机制**，具体实现方式是在线程语句后面添加了一个 `for` 循环语句，让线程会一直循环执行。
* 第二点是引入了 **事件**，在线程运行过程中，等待用户的操作事件，等待过程中线程处于暂停状态，等接收到用户的操作之后再激活线程，然后继续执行。

#### **2.3 处理其他线程发送过来的任务**

上面两个场景都是发生在 JS 线程上面的场景，那么如果其它线程或进程发来一些任务呢？

渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

浏览器是通过**消息队列**的方式来让线程模型接收其它线程发送来的的消息的。

**消息队列是一种数据结构，用来存放要执行的任务**。它符合 **队列先进先出** 的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

这个消息队列是这样的过程：

* 在线程之间添加一个 **消息队列**；
* IO 线程中产生的新任务添加进 **消息队列尾部**；
* 渲染主线程会循环地 **从消息队列头部中读取任务**，执行任务。

#### **2.4 处理其他进程发送过来的任务**

线程之间的消息通信可以通过消息队列来实现，那么进程之间呢？在 Chrome 中，跨进程之间的任务也是频繁发生的，那么渲染进程如何处理其他进程发送过来的任务呢？

渲染进程专门有一个 **IO 线程** 用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。

完整的执行概略图如下所示：

![JS 单线程执行](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81ccc92d97b94822bde4cf6485de124f\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

#### 2.5 浏览器为什么可以执行异步任务

JS 是单线程的，在同一个时间只能做一件事情，**那为什么浏览器可以同时执行异步任务呢？**

这是因为浏览器是多线程的，当 JS 需要执行异步任务时，浏览器会另外启动一个线程去执行该任务。也就是说，JavaScript是单线程的指的是执行JavaScript代码的线程只有一个，是浏览器提供的JavaScript引擎线程（主线程）。除此之外，浏览器中还有定时器线程、 HTTP 请求线程等线程，这些线程主要不是来执行 JS 代码的。

比如主线程中需要发送数据请求，就会把这个任务交给异步 HTTP 请求线程去执行，等请求数据返回之后，再将 callback 里需要执行的 JS 回调交给 JS 引擎线程去执行。也就是说，浏览器才是真正执行发送请求这个任务的角色，而 JS 只是负责执行最后的回调处理。所以这里的异步不是 JS 自身实现的，而是浏览器为其提供的能力。

下图是Chrome浏览器的架构图：

![Chrome 简易架构](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aac70e314114e5297a8aeec3bfe853f\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

可以看到，Chrome不仅拥有多个进程，还有多个线程。以渲染进程为例，就包含GUI渲染线程、JS引擎线程、事件触发线程、定时器触发线程、异步HTTP请求线程。这些线程为 JS 在浏览器中完成异步任务提供了基础。

### 3. JS 单线程问题

**页面线程所有执行的任务都来自于消息队列**。消息队列是先进先出的特性，即放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决：

#### **3.1 当出现高优先级的任务时应该怎么办？**

比如一个典型的场景是 **监控 DOM 节点的变化情况**（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。

如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

这也就是说，**如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性**。

那该如何权衡效率和实时性呢？针对这种情况，**微任务**就应用而生了。

* 通常把 **消息队列中的任务称为宏任务**，**每个宏任务中都包含了一个微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了 **执行效率** 的问题。
* 等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是 **执行当前宏任务中的微任务**，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了 **实时性问题**。

#### **3.2 单个任务执行时间过长时应该怎么办？**

因为所有的任务都是在单线程中执行的，所以 **每次只能执行一个任务**，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。

针对这种情况，JavaScript 是通过 **回调功能** 来规避这种问题的，也就是让要执行的 JavaScript 任务滞后执行。

## 三、Event Loop

### &#x20;1. 宏任务

宏任务（**macrotask**）在 ES6 规范中称为 **task**。

为了协调任务有条不紊地在主线程上执行，页面进程引入了 **消息队列** 和 **事件循环机制**，渲染进程内部也会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 `for` 循环，不断地从这些任务队列中取出任务并执行任务。这些消息队列中的任务就称为 **宏任务**。

一些常见的宏任务有：

* 渲染事件（如解析 DOM、计算布局、绘制等）；
* 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
* JS 脚本执行事件；
* 网络请求完成、文件读写完成事件。

消息队列中的任务是通过事件循环系统来执行的，通过 WHATWG 规范中定义事件循环机制，大致流程如下：

* 先从多个消息队列中选出一个最老的任务，这个任务称为 `oldestTask`；
* 然后循环系统记录任务开始执行的时间，并把这个 `oldestTask` 设置为当前正在执行的任务；
* 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 `oldestTask`；
* 最后统计执行完成的时长等信息。

这也就是宏任务的执行流程。

宏任务可以满足大部分的日常需求，但是宏任务的时间粒度比较大，是不能精确控制执行的时间间隔的。

页面的渲染事件、各种 IO 的完成事件、执行 JS 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。

也就是说高优先级的任务没有办法通过消息队列去控制执行任务的时机，于是在这种情况下，微任务诞生了。

### 2. 微任务

**微任务（microtask）** 在 ES6 规范中称为 `job`。

**微任务可以在实时性和效率之间做一个有效的权衡**。浏览器基于微任务的技术有 `MutationObserver`、`Promise` 以及以 `Promise` 为基础开发出来的很多其他的技术。

微任务 **是一个需要异步执行的回调函数，执行时机是在主函数执行结束之后、当前宏任务结束之前**。

要搞清楚微任务系统是怎么运转的，得站在 V8 引擎的层面来分析：当 JS 执行一段脚本（一个宏任务）的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个 **微任务队列**。也就是说 **每个宏任务都关联了一个微任务队列**。

下面通过分析两个重要的时间点（微任务产生的时机和执行微任务队列的时机）来理解微任务。

#### **2.1 产生微任务的时机**

在现代浏览器里面，产生微任务有两种方式：

* 第一种方式是 **使用 `MutationObserver` 监听某个 DOM 节点**，然后再通过 JS 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
* 第二种方式是 **使用 `Promise`**，当调用 `Promise.resolve()` 或者 `Promise.reject()` 的时候，也会产生微任务。

通过使用 `MutationObserver` 监听 DOM 节点变化产生的微任务或者使用 `Promise` 产生的微任务都会被 JS 引擎按照顺序保存到 **微任务队列** 中。

#### **2.2 执行微任务的时机**

通常情况下，在 **当前宏任务中的 JS 代码快执行完成时**，即 **在 V8 引擎准备退出全局执行上下文并清空调用栈时**，V8 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 规范 **把执行微任务的时间点称为检查点**。

如果在执行微任务的过程中，产生了新的微任务，**同样会将该微任务继续添加到当前微任务队列中**，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说**在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行**。

#### **2.3 微任务特点**

* **微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列**。
* **微任务的执行时长会影响到当前宏任务的时长**。
  * JS 是单线程执行代码的，在一个宏任务在执行过程中，产生了 `100` 个微任务，执行每个微任务的时间是 `10` 毫秒，那么执行这 `100` 个微任务的时间就是 `1000` 毫秒，也可以说这 `100` 个微任务让宏任务的执行时间延长了 `1000` 毫秒。
  * 所以在写代码的时候一定要注意控制微任务的执行时长。
* **在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行**。

### 3. 浏览器中的 Event Loop

**主线程从消息队列中读取事件**，这个过程是循环不断的，所以整个的这种运行机制又称为 **Event Loop （事件循环）**。

而不同的任务源会分到不同的消息队列中，任务源可以分为 **微任务（microtask）** 和 **宏任务（macrotask）**。在 ES6 规范中，`microtake` 称为 `jobs`，`macrotask` 称为 `task`。

⻚面渲染事件，各种 IO 的完成事件等随时被添加到消息队列中，一直会保持 **先进先出** 的原则执行，我们不能准确地控制这些事件被添加到消息队列中的位置。但是这个时候突然有 **高优先级** 的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了 **微任务队列**。

* 微任务包括 `process.nextTick`，`promise`，`MutationObserver`，其中 `process.nextTick` 为 Node.js 独有。
* 宏任务包括 `<script>`，`setTimeout`，`setInterval`，`setImmediate`，I/O ，`UI rendering`。

![Event Loop](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/915749c40ec544abb21d826b0a188541\~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

Event Loop 的执行顺序如下所示：

* 首先执行执行栈中的 **同步代码**，这属于宏任务
* 当执行完所有同步代码后，**执行栈为空**，查询是否有 **异步代码** 需要执行
* 之后执行所有 **微任务**
* 当执行完所有微任务后，如有必要会渲染页面
* 然后开始下一轮 Event Loop

![Event Loop](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa4b42e4af\~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 4. Node 中的 Event Loop <a href="#item-5" id="item-5"></a>

Node 中的事件循环机制表现出的状态与浏览器大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现依赖 libuv 引擎。Node的事件循环存在几个阶段。

* 如果是 node10 及其之前版本，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列中的任务。
* node 版本更新到 11 之后，Event Loop 运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout, setInterval 和 setImmediate)就立刻执行微任务队列，跟浏览器趋于一致。下面例子中的代码是按照最新的去进行分析的。

#### 事件循环模型 <a href="#item-5-4" id="item-5-4"></a>

```
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

#### 事件循环各阶段详解 <a href="#item-5-5" id="item-5-5"></a>

外部输入数据 --> 轮询阶段（poll） --> 检查阶段(check) --> 关闭事件回调阶段(close callback) --> 定时器检查阶段(timer) --> I/O 事件回调阶段(I/O callbacks) --> 闲置阶段(idle, prepare) --> 轮询阶段...

这些阶段大致的功能如下：

* 定时器检测阶段(timers): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
* I/O事件回调阶段(I/O callbacks): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
* 闲置阶段(idle, prepare): 这个阶段仅在内部使用，可以不必理会
* 轮询阶段(poll): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
* 检查阶段(check): setImmediate()的回调会在这个阶段执行。
* 关闭事件回调阶段(close callbacks): 例如socket.on('close', ...)这种close事件的回调

poll：这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。\
这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。

check: 该阶段执行setImmediate()的回调函数。

close: 该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

timer阶段: 这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

I/O callback阶段：除了以下的回调函数，其他都在这个阶段执行：

* setTimeout()和setInterval()的回调函数
* setImmediate()的回调函数
* 用于关闭请求的回调函数，比如socket.on('close', ...)

## 四、考点 <a href="#item-5-6" id="item-5-6"></a>

### 1. 常见 Event Loop 面试题

#### **`setTimeout`**

`setTimeout` 是 **异步执行函数**，因为不确定执行时机，所以会是一个宏任务，当主线程运作到此函数时，`setTimeout` 里面的回调函数会进入 **消息队列（宏任务队列）** 中等待，然后运行 `setTimeout` 后面的语句，当执行完当前事件（执行栈清空）后， `setTimeout` 中的回调才会在下次（或某一个）事件循环中进入执行栈被执行。

```javascript
console.log('setTimeout start')
setTimeout(function () {
  console.log('setTimeout execute')
}, 0)
console.log('setTimeout end')
```

输出结果为：`setTimeout start` => `setTimeout end` => `setTimeout execute`

#### **`Promise`**

`Promise` 本身是同 **步的立即执行函数**，当在执行体中执行 `resolve()` 或者 `reject()` 时，会把`resolve()`或者 `reject()` 丢到 **当前宏任务中的微任务队列** 中，**通过 `.then` 进行延时绑定回调**，当执行完当前事件（执行栈清空）后才会去执行 `resolve()` 或者 `reject()` 的方法。

```javascript
console.log('script start');
new Promise(function (resolve) {
  console.log('promise1');
  resolve();
  console.log('promise1 end');
}).then(function () {
  console.log('promise2');
})
setTimeout(function () {
  console.log('setimeout');
}, 0)
console.log('script end');
```

输出结果为：`script start` => `promise1` => `promise1 end` => `script end` => `promise2` => `setimeout`

#### **`async`/`await`**

`async` 函数返回一个 `promise` 对象，当函数执行的时候，一旦遇到 `await` 就会先返回去执行 `async` 外的代码，等到调用栈清空之后，触发的异步操作（`await`的函数）完成，再执行 `await` 后面的语句，可以把 `await` 看成是让出线程的标志；`await` 函数后的语句相当于在 `then` 回调中执行。

```javascript
async function async1() {
  console.log('async1 start')
  await async2();
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
async1();
console.log('script end')
```

输出结果为：`script start` => `async1 start` => `async2` => `script end` => `async1 end`

#### **宏任务和微任务结合来看看**

来看这段代码：

```javascript
console.log('script start')
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
async1()
setTimeout(function () {
  console.log('setTimeout')
}, 0)
new Promise(resolve => {
  console.log('promise1 start')
  resolve()
  console.log('promise1 end')
}).then(function () {
  console.log('promise2')
}).then(function () {
  console.log('promise3')
})
console.log('script end')
```

输出结果是：`script start` => `async1 start` => `async2` => `promise1 start` => `promise1 end` => `script end` => `async1 end` => `promise2` => `promise3` => `setTimeout`

以上代码虽然 `setTimeout` 写在 `Promise` 之前，但是因为 `Promise` 属于微任务而 `setTimeout` 属于宏任务，所以会有以上的打印。

#### 下面代码输出什么 <a href="#item-6-10" id="item-6-10"></a>

```javascript
const p = function() {
    return new Promise((resolve, reject) => {
        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 0)
            resolve(2)
        })
        p1.then((res) => {
            console.log(res);
        })
        console.log(3);
        resolve(4);
    })
}


p().then((res) => {
    console.log(res);
})
console.log('end');
```

1. 执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中，遇到`p1.then`会先放到微任务队列中，接着往下执行，输出 `3`
2. 遇到 `p().then` 会先放到微任务队列中，接着往下执行，输出 `end`
3. 同步代码块执行完成后，开始执行微任务队列中的任务，首先执行 `p1.then`，输出 `2`, 接着执行`p().then`, 输出 `4`
4. 微任务执行完成后，开始执行宏任务，setTimeout, `resolve(1)`，但是此时 `p1.then`已经执行完成，此时 `1`不会输出。

最后的执行结果如下

* 3
* end
* 2
* 4

你可以将上述代码中的 `resolve(2)`注释掉, 此时 1才会输出，输出结果为 `3 end 4 1`。

```javascript
const p = function() {
    return new Promise((resolve, reject) => {
        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 0)
        })
        p1.then((res) => {
            console.log(res);
        })
        console.log(3);
        resolve(4);
    })
}


p().then((res) => {
    console.log(res);
})
console.log('end');
```

* 3
* end
* 4
* 1

## 五、参考

* [事件循环机制（Event Loop）](https://juejin.cn/post/6977746526441308173)
* [彻底搞懂 JavaScript 事件循环](https://juejin.cn/post/6992167223523541023)
* [不同的回调执行时机：宏任务和微任务](https://juejin.cn/post/6978122767451291679)
* [JavaScript 核心进阶 - 事件循环机制](https://xiaozhuanlan.com/advance/5839760214)
* [JS 事件循环机制](https://juejin.cn/post/6844903638238756878)
* [JavaScript 中的 Event Loop（事件循环）机制](https://segmentfault.com/a/1190000022805523)
